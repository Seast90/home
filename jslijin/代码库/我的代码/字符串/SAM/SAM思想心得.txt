SAM思想心得

1.suffix links 构成一棵有根有向树（有称parent树），树边指向父亲，

叶子节点必然是前缀节点（所代表的串中最大长度的那个必然是总串的前缀）; 

2.每一条叶路径（叶子走到根）上代表串集合的并就是此叶子对应前缀的所有后缀，

由此可以用dp静态维护某个时刻，串中任意前缀的所有后缀信息并，储存在叶子节点

3.对parent树上的所有节点做拓扑排序，其实就是按照深度排序，得到的拓扑序列，

本质上就是bfs序列；由此做dp，可以从上到下，维护点到根路径信息，也可以由下到上维护子树信息

4.自动机对某个串进行模式识别，称对此串运行自动机；运行一次，线性时间可以求出串中每个位置向前与模式串的最长匹配长度

（或者最长长度同时的最左最右下标等信息），也可以求条件匹配最长长度；

在串的某个位置，会使焦点转移到自动机的某个节点，则这个状态节点就是串中此位置相对于模式串的一种总结

（此位置说法等价于以此位置结束的该状态的代表串，前缀的某些后缀），一方面它揭示匹配，另一方面提供信息

5.运行自动机对一个串s进行识别的过程，其本质实质上是对该串的一种加速化的串搜索/穷举，

这种搜索合并了完全相同的子串并对模式串具体位置不敏感而对被运行串位置敏感，这种搜索会考虑到所有的s子串，

只要取识别过程中由转移走到的所有状态节点的信息并，就可以得到s串中所有可匹配的子串的信息并

而如果对明知道存在于模式串中的串s进行识别，那么就会得到s中所有子串的信息并

6.与字典序有关的一些问题，多半依赖于对transition edges 的dfs，优先选择字母小的进行转移，这样穷举得到的子串就是按照字典序

排好的子串，并且没有并列的情况，相当于sa[]；如果在字典意义下，满足某些与字典无关的条件，可以先标记可接受的状态节点，然后dfs到可接受状态才接受

7.dp的时候我们对每个状态维护什么信息是因题而异的，但是可以这样思考：假设我们拼凑好了模式串，并且构建了自动机；如果我们暴力穷举待运行串

s的所有子串，我们需要明确我们想要知道拿出一个子串相对于自动机中的模式串中的什么信息；比如给定串t和s，求s中有多少个子串（不必不同），在t中恰好

出现素数次；以t建自动机，我们期望知道任何一个子串，在t中的出现次数；然后做树形dp，求节点到根的路径上有多少个点权是素数；

这样穷举时，一旦匹配，就提取信息，判断之并更新答案（注意：当前节点信息可能不能够全部取，可能要舍弃一部分）；

8.关于串穷举的顺序的两种理解：第一种，先穷举右端点，再穷举左端点，穷举右端点时，左端点不必从头穷举，只要接着上次即可（单调性），一旦右端点右移动，

仍然可以匹配，则左端点不必移动，反之，移动左端点；第二种，先穷举左端点，再穷举右端点，这个很好理解，左端点固定的时候，右端点不断右移动，

知道不可以匹配，这样就不必继续向右移动了，永远不会匹配了（单调性）；这样，该左端点穷举完毕，左端点右移动，注意此时，右端点不必从左端点处

开始移动，直接向右移动，这也是单调性，因为是显然的；

9.串长度越长，约束越强，出现的概率越小；因此，串穷举的本质，可以认为，可以匹配时将一个串右边增加长度，增大约束；不可以匹配时，左边减少

长度，减少约束，寻求匹配；

10.parent树相当于，原串的反串的后缀树，把原串取反，然后将后缀一个个的插入trie树，并且压缩
