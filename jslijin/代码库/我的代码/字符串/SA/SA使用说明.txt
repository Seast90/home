SA使用说明

【变量与数组约定】

sa[i] 排名为i的后缀(对应下标)

R[i]  i这个后缀的排名

H[i]  排名为i的后缀与它的前驱后缀（排名为i-1）的最长公共前缀长度

h[i]  i这个后缀和它的前驱后缀的最长公共前缀长度

n     字符串长度，下标是  0  -  n-1

m     最大字符的int值

cnt   表示sa[]被分成群组的个数

str_cnt   多串模式使用，表示串的个数

home[i]  多串模式使用，表示多串串联之后的，以i下标开头的后缀的归属的帮派编号（来自的串编号，1到str_cnt）,注意连接符一律归属于0

num[i]   多串模式使用，表示指定范围内，i这个帮派的后缀的个数

num0   表示指定范围内，num[]中非0的数目，含义是指定范围内的后缀来自于不同帮派的个数

bool cmp(int *y,int a,int b,int k)    比较函数y[a]==y[b]&&y[a+k]==y[b+k]

void init_sa()    预处理sa[]

void init_H()     预处理R[],H[],h[](如不需要可删除)

int Q_lcp(int x,int y)   询问后缀x和后缀y的最长公共前缀





void divide_group(int k,int x[]) 

以k为关键值对sa[]进行分组，H[i]<k，表示i-1和i要分开，一个组最少一个元素

生成的结果保存在x[],采用区间左闭右开；第i个组的下标范围是：[x[i-1],x[i]-1],

cnt保存组的总个数，组的编号从1开始。x[cnt]始终为n。sa[]下标是0  -  n-1

组内的元素满足：从同一个组内，任取两个后缀，其最长公共前缀长度不小于k


bool check_group(int l,int r)

用于组内check，l到r表示组的区间范围，闭区间

这个函数是用户需要关注的函数，不同的题目需要满足不同的条件

常用的条件是：组内元素来自至少x个串，组内存在一对后缀其前k个字母不重叠等


bool check(int ans)   二分答案对于ans的check函数


int binary(int l,int r)    封装好的二份答案的程序，通常不需要修改（答案越大，越不容易，否则反向）

int Q()          用户接口，主要查询函数，返回答案

SA()          构造函数，用于多模式串，单串请删除，用到Insert的程序需要（内部初始化）



void Clear()    多串模式下，每组数据的初始化清空函数，其后可以调用Insert接口

void Insert(char _s[],int op=0,int _n=0)

多模式串的插入函数，op==0是正向，其他是反向，默认正向，_n默认是_s的串长，意思是如不指定串长，就按整个串计算，

这允许插入串的一部分，同时，如果不带参数，表示内部已经生成好s[]和n。

往往可以用:SA()+ Clear()+Insert(有参数)+Init()完成多模式串的初始化



int Q_lcs(int x,int y)    多串意义下，查询串x和串y的最长公共子串的长度

void count(int l,int r)   多串意义下使用，表示将sa[]的[l,r]这一段进行归属统计，生成的结果保存在num[]和num0




【注意点】

1.int版本，必须要传入数组的指定长度

2.int版本，要注意修改m的默认大小和插入符的初值

3.注意修改N的范围，是所有串的总长+串的个数+一个小常数（比如5）

4.单串的情况，一定要注意注释掉SA()构造函数

5.写好程序之后，注意注释掉无关紧要的数组和变量，函数，再次测试，不需要的可以不加

6.注意check_group()组内判断函数，有可能需要用到全局的个别变量，注意调整变量定义位置

7.注意多串模式下的，N要翻倍到串的个数*N，否则会RE

8.调用binary函数二分答案的时候，注意不只是binary(1,n)，有可能下界是0

9.多串模式下的多组数据，切记每组数据都要Clear()

10.注意在分组divide_group()函数调用后，有的组只有一个元素，有时候要考虑特殊情况

11.Q_lcs()会自动考虑答案是否为0，Q_lcp()会自动考虑自己和自己的最长公共前缀（只有自己一个串），ST查询需要注意下标不可越界，并且l<=r

12.扫描sa[]数组，任何时刻，锁定k这一项，注意sa[k]才表示该后缀的原地址下标

13.注意如果调试的时候，发现某个时刻binary(l,r)在合法的区间内，返回答案是-1，多半是组内check_group()写错

14.如果RE，注意m初始值：m='z'+1(只有大小写字母数字)

15.注意num[]数组的大小，就是插入串的个数，要进行调整；务必注意未必等于读入的串的个数，切记

16.注意函数内部传入的指针，不要对其使用memset,或者sizeof操作

17.多串模式下，注意只有一个串的时候，往往是特殊情况；单串注意长度是1的情况

18.注意：多串如果串的个数很多，请用int版本；char[]版本只支持大约40个左右的串；否则注意可能会RE

if (n) home[n]=0,s[n++]=(str_cnt+1<97)?str_cnt+1:str_cnt-96+123;

替换Insert()第一句话，可以追加到支持100个串长度（串只含小写字母）

而int版本多串模式默认支持插入大约1000个串

19.如果要变更num0含义，表示组内的后缀来自的帮派个数（满足：此帮派至少包含组内的t个后缀成员）t默认是1

可以修改count()函数：参见例题12（spoj220）

inline void count(int l,int r) {
    mem(num,0); num0=0; rep(i,l,r) num0+=(num[home[sa[i]]]++==t-1); num0-=(num[0]>=t);
} 

20.单串模式下，注意不指定传入长度的情况下，务必保证原串末尾有'\0'；多串模式下，数据结构会自动将最后一个字符后面的设为哨兵字符'\0'，

int版本中，是m-1(最大可能插入符)。这体现在init_H()中，反了会wa或者re



